// https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String   @id @default(cuid())
  username    String   @unique
  email       String?  @unique
  phoneNumber String?  @unique
  password    String
  avatar      String?
  inviteCode  String?  @unique
  isOnline    Boolean  @default(false)
  lastSeen    DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  sentMessages     Message[]           @relation("MessageSender")
  chatParticipants ChatParticipant[]
  leagueMembers    LeagueMember[]
  leagueAdmins     League[]           @relation("LeagueAdmin")
  leagueAdminRoles LeagueAdmin[]      // Additional admin roles in leagues
  eventParticipants EventParticipant[]
  eventAdmins      Event[]            @relation("EventAdmin")
  friendships      Friendship[]       @relation("UserFriendships")
  friendOf         Friendship[]       @relation("FriendOf")
  sentInvitations Invitation[]  @relation("Inviter")
  receivedInvitations Invitation[]  @relation("Invitee")
  messageReactions MessageReaction[]
  messageReadReceipts MessageReadReceipt[]

  @@map("users")
}

model Invitation {
  id  String @id @default(cuid())
  code String @unique
  inviterId String
  inviter User @relation("Inviter", fields: [inviterId], references: [id])
  inviteeId String?
  invitee User? @relation("Invitee", fields: [inviteeId], references: [id])
  status FriendshipStatus @default(PENDING)
  expiredAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("invitations")
}

model Chat {
  id        String   @id @default(cuid())
  name      String?
  type      ChatType @default(DIRECT)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  participants ChatParticipant[]
  messages     Message[]

  @@map("chats")
}

model ChatParticipant {
  id      String @id @default(cuid())
  chatId  String
  userId  String
  joinedAt DateTime @default(now())
  lastReadAt DateTime @default(now())
  readReceiptsEnabled Boolean @default(true)

  // Relations
  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([chatId, userId])
  @@map("chat_participants")
}

model Message {
  id        String      @id @default(cuid())
  content   String
  type      MessageType @default(TEXT)
  senderId  String
  chatId    String
  mediaUrl  String?
  replyToId String?
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  // Relations
  sender   User            @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  chat     Chat            @relation(fields: [chatId], references: [id], onDelete: Cascade)
  reactions MessageReaction[]
  readReceipts MessageReadReceipt[]
  replyTo  Message?        @relation("MessageReplies", fields: [replyToId], references: [id])
  replies  Message[]       @relation("MessageReplies")

  @@map("messages")
}

model MessageReaction {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  emoji     String
  createdAt DateTime @default(now())

  // Relations
  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId, emoji])
  @@map("message_reactions")
}

model MessageReadReceipt {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  readAt    DateTime @default(now())
  
  // Relations
  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([messageId, userId])
  @@map("message_read_receipts")
}

model League {
  id          String   @id @default(cuid())
  name        String
  description String?
  adminId     String
  isPrivate   Boolean  @default(false)  // Private leagues require invitation
  inviteCode  String?  @unique          // Unique code for joining private leagues
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  admin   User           @relation("LeagueAdmin", fields: [adminId], references: [id], onDelete: Cascade)
  members LeagueMember[]
  rules   LeagueRule[]
  events  Event[]
  admins  LeagueAdmin[]  // Additional admins (delegated)

  @@map("leagues")
}

model LeagueMember {
  id       String @id @default(cuid())
  userId   String
  leagueId String
  points   Int    @default(0)
  rank     Int    @default(0)
  joinedAt DateTime @default(now())

  // Relations
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  league League @relation(fields: [leagueId], references: [id], onDelete: Cascade)

  @@unique([userId, leagueId])
  @@map("league_members")
}

// Additional admins for leagues (delegated admin rights)
model LeagueAdmin {
  id       String @id @default(cuid())
  userId   String
  leagueId String
  grantedAt DateTime @default(now())
  grantedBy String  // User ID who granted admin rights

  // Relations
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  league League @relation(fields: [leagueId], references: [id], onDelete: Cascade)

  @@unique([userId, leagueId])
  @@map("league_admins")
}

model LeagueRule {
  id          String @id @default(cuid())
  leagueId    String
  title       String
  description String
  points      Int
  category    PointCategory @default(WINS)  // Type of points (WINS, PARTICIPATION, BONUS, PENALTY)
  createdAt   DateTime @default(now())

  // Relations
  league League @relation(fields: [leagueId], references: [id], onDelete: Cascade)

  @@map("league_rules")
}

model Event {
  id              String    @id @default(cuid())
  title           String
  description     String?
  leagueId        String?   // Optional - events can be standalone or league-tied
  adminId         String    // Event creator/admin
  startDate       DateTime
  endDate         DateTime
  maxParticipants Int?
  isPrivate       Boolean   @default(false)  // Private events require invitation
  inviteCode      String?   @unique          // Unique code for joining private events
  hasScoring      Boolean   @default(true)   // Whether event uses scoring system or simple list
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  league       League?            @relation(fields: [leagueId], references: [id], onDelete: Cascade)
  admin        User               @relation("EventAdmin", fields: [adminId], references: [id], onDelete: Cascade)
  participants EventParticipant[]
  rules        EventRule[]
  invitations  EventInvitation[]  // Invitations for non-friends

  @@map("events")
}

model EventParticipant {
  id       String @id @default(cuid())
  eventId  String
  userId   String
  points   Int    @default(0)
  rank     Int    @default(0)
  joinedAt DateTime @default(now())

  // Relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@map("event_participants")
}

model EventRule {
  id          String @id @default(cuid())
  eventId     String
  title       String
  description String
  points      Int
  category    PointCategory @default(WINS)  // Type of points (WINS, PARTICIPATION, BONUS, PENALTY)
  createdAt   DateTime @default(now())

  // Relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@map("event_rules")
}

// Event invitations for non-friends (shareable links)
model EventInvitation {
  id        String @id @default(cuid())
  eventId   String
  code      String @unique  // Unique invitation code
  email     String?         // Optional email for invitation
  phoneNumber String?       // Optional phone for invitation
  status    InvitationStatus @default(PENDING)
  expiresAt DateTime        // Invitation expiration
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@map("event_invitations")
}

model Friendship {
  id       String        @id @default(cuid())
  userId   String
  friendId String
  status   FriendshipStatus @default(PENDING)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user   User @relation("UserFriendships", fields: [userId], references: [id], onDelete: Cascade)
  friend User @relation("FriendOf", fields: [friendId], references: [id], onDelete: Cascade)

  @@unique([userId, friendId])
  @@map("friendships")
}

// Enums
enum ChatType {
  DIRECT
  GROUP
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  FILE
  VOICE
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

// Point categories for leagues and events
enum PointCategory {
  WINS          // Points for winning rounds/games
  PARTICIPATION // Points for participating
  BONUS         // Custom bonus points
  PENALTY       // Negative points for rule violations
}

// Invitation status for event invitations
enum InvitationStatus {
  PENDING   // Invitation sent but not yet accepted
  ACCEPTED  // Invitation accepted
  EXPIRED   // Invitation expired
  CANCELLED // Invitation cancelled
}
